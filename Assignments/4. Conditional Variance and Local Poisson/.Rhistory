knitr::opts_chunk$set(echo = TRUE)
# Clears plots
while (dev.cur() != 1) {
dev.off()
}
# Clears global environment
rm(list = ls())
set.seed(1234)
library(sm)
data(aircraft)
help(aircraft)
attach(aircraft)
lgPower <- log(Power)
lgSpan <- log(Span)
lgLength <- log(Length)
lgWeight <- log(Weight)
lgSpeed <- log(Speed)
lgRange <- log(Range)
plot(Yr, lgWeight)
# Function loc.pol.reg option
source("locpolreg.R")
# Leave-one-out CV to select bandwidth
h.cv.gcv <- function(x, y , h.v = exp(seq(log(diff(range(Yr))/20),
log(diff(range(Yr))/4), l = 10)),
p = 1, type.kernel = "normal") {
cv <- h.v*0
gcv <- h.v*0
for (i in (1:length(h.v))) {
h <- h.v[i]
aux <- locpolreg(x = x, y = y, h = h, p = p, tg = x,
type.kernel = type.kernel, doing.plot = FALSE)
S <- aux$S
h.y <- aux$mtgr
hii <- diag(S)
av.hii <- mean(hii)
cv[i] <- mean(((y - h.y)/(1 - hii))^2)
gcv[i] <- mean(((y - h.y)/(1 - av.hii))^2)
}
return(list(h.v = h.v, cv = cv, gcv = gcv))
}
h.v <-  exp(seq(from = log(1), to = log(20), length = 30))
out.h.cv <- h.cv.gcv(x = aircraft$Yr, y = lgWeight, h.v = h.v)
h.loocv <- h.v[which.min(out.h.cv$cv)]
# Function sm.regression option
library(KernSmooth)
h_m <- dpill(Yr, lgWeight)
aircraft.sm_reg <- sm.regression(Yr, lgWeight, h_m,
eval.points = seq(min(Yr), max(Yr), length.out = length(Yr)))
yhat.sm <- aircraft.sm_reg$estimate
epsilon.sm <- (lgWeight - yhat.sm)^2
z.sm <- log(epsilon.sm)
h2_sm <- dpill(Yr, z.sm)
aircraft.sm_reg2 <- sm.regression(Yr, z.sm, h2_sm,
eval.points = seq(min(Yr), max(Yr), length.out = length(Yr)),
ylim = c(min(z.sm), 5),
xlab = "Year", ylab = "log Squared est. residuals",
lwd = 2, col = "blue", cex = 0.7)
q_hat = aircraft.sm_reg2$estimate
legend("topleft", legend = "q_hat", col = "blue", lty = 1, lwd = 2)
sigma_square_hat = exp(q_hat)
year.points = aircraft.sm_reg$eval.points
# Plot squared residuals against x_i
plot(year.points, epsilon.sm, xlab = "Year", ylab = "Squared est. residuals", col = "grey", cex = 0.7)
# Superimpose the estimated function sigma_square_hat
lines(year.points, sigma_square_hat, col = "blue",lwd = 1.5)
legend("topleft", legend = "sigma_square_hat", col = "blue", lty = 1, cex = 0.8, lwd = 1.5)
# Plot the estimate m_hat
plot(Yr, lgWeight, xlab = "Year", ylab = "log Weight", col = "grey", cex = 0.7)
lines(year.points, yhat.sm, type = "l", col = "blue", lwd = 1.5)
# Superimpose the estimated function sigma_square_hat
lines(year.points, yhat.sm + 1.96 * sqrt(sigma_square_hat), col = "red", lty = 2, lwd = 1.5)
lines(year.points, yhat.sm - 1.96 * sqrt(sigma_square_hat), col = "red", lty = 2, lwd = 1.5)
# Add legend with adjusted parameters
legend("topleft", legend = c("Data", "m_hat", "Confidence Interval"),
col = c("grey", "blue", "red"),
lty = c(NA, 1, 2), pch = c(1, NA, NA), lwd = 1.5, cex = 0.8)
data <- read.csv2('HDI.2017.subset.csv')
# Function to estimate the log-likelihood of a Poisson distribution
# via cross-validation
loglik.CV.poisson <- function(X, Y, h){
n <- length(X)
pred <- sapply(1:n,
function(i, X, Y, h){
sm.poisson(x = X[-i], y = Y[-i], h = h, eval.points = X[i],
display = "none")$estimate
},   X, Y, h)
like <- exp(-pred)*(pred^Y)/factorial(Y)
return(mean(log(like)))
}
h.cv.sm.poisson <- function(X, Y, h.range=NULL, l.h=10, method=loglik.CV.poisson){
cv.h <- numeric(l.h)
if (is.null(h.range)) {
hh <- c(h.select(X, Y, method = "cv"),
h.select(X, Y, method = "aicc"))
h.range <- range(hh)*c(1/1.1, 1.5)
}
i <- 0
gr.h <- exp(seq(log(h.range[1]), log(h.range[2]), l = l.h))
for (h in gr.h) {
i <- i + 1
cv.h[i] <- method(X, Y, h)
}
return(list(h = gr.h,
cv.h = cv.h,
h.cv = gr.h[which.max(cv.h)]))
}
le.fm.r <- round(data$le.fm)
h.CV.loglik <- h.cv.sm.poisson(X = data$Life.expec, Y = le.fm.r, h.range = c(1,20),
method = loglik.CV.poisson)
plot(h.CV.loglik$h,h.CV.loglik$cv.h, main = "Log-Likelihood ~ h",
xlab = "h", ylab = "CV-LogLikelihood")
lines(h.CV.loglik$h,h.CV.loglik$cv.h)
knitr::opts_chunk$set(echo = TRUE)
# Clears plots
while (dev.cur() != 1) {
dev.off()
}
# Clears global environment
rm(list=ls())
library(sm)
data(aircraft)
help(aircraft)
attach(aircraft)
lgPower <- log(Power)
lgSpan <- log(Span)
lgLength <- log(Length)
lgWeight <- log(Weight)
lgSpeed <- log(Speed)
lgRange <- log(Range)
plot(Yr, lgWeight, cex = 0.6, xlab="Year", ylab = "log Weight")
library(KernSmooth)
x <- aircraft$Yr
y <- lgWeight
h_sm <- dpill(x, y)
aircraft.sm_reg <- sm.regression(x, y, h_sm,
eval.points =seq(min(x), max(x), length.out=length(x)),
xlab = "Year", ylab = "log ",
lwd=2, col="blue", cex=0.5)
legend("topleft", legend = "m_hat", col = "blue", lty = 1, lwd=2)
m_hat = aircraft.sm_reg$estimate
epsilon_hat <- y - m_hat
z <- log(epsilon_hat^2)
h2_sm <- dpill(x, z)
aircraft.sm_reg2 <- sm.regression(x, z, h2_sm,
eval.points =seq(min(x), max(x), length.out=length(x)),
ylim = c(min(z), 5),
xlab = "Year", ylab = "log Squared est. residuals",
lwd=2, col="blue", cex=0.5)
legend("topleft", legend = "q_hat", col = "blue", lty = 1, lwd=2)
q_hat = aircraft.sm_reg2$estimate
sigma_square_hat = exp(q_hat)
year.points = aircraft.sm_reg$eval.points
# Plot squared residuals against xi
plot(year.points, epsilon_hat^2, xlab = "Year", ylab = "Squared est. residuals", col="grey", cex=0.7)
# Superimpose the estimated function sigma_square_hat
lines(year.points, sigma_square_hat, col = "blue",lwd=1.5)
legend("topleft", legend = "sigma_square_hat", col = "blue", lty = 1, cex = 0.8,lwd=1.5)
# Plot the estimate m_hat
plot(x, y, xlab = "Year", ylab = "log Weight", col="grey", cex = 0.7)
lines(year.points, m_hat, type = "l", col = "blue", lwd=1.5)
# Superimpose the estimated function sigma_square_hat
lines(year.points, m_hat + 1.96 * sqrt(sigma_square_hat), col = "red", lty=2, lwd=1.5)
lines(year.points, m_hat - 1.96 * sqrt(sigma_square_hat), col = "red", lty=2, lwd=1.5)
# Add legend with adjusted parameters
legend("topleft", legend = c("Data", "m_hat", "Confidence Interval"),
col = c("grey", "blue", "red"),
lty = c(NA, 1, 2), pch = c(1, NA, NA), lwd = 1.5, cex = 0.8)
source("locpolreg.R")
# Leave-one-out CV to select bandwidth
h.cv.gcv <- function(x,y,h.v = exp(seq(log(diff(range(x))/20),
log(diff(range(x))/4),l=10)),
p=1,type.kernel="normal"){
n <- length(x)
cv <- h.v*0
gcv <- h.v*0
for (i in (1:length(h.v))){
h <- h.v[i]
aux <- locpolreg(x=x,y=y,h=h,p=p,tg=x,
type.kernel=type.kernel, doing.plot=FALSE)
S <- aux$S
h.y <- aux$mtgr
hii <- diag(S)
av.hii <- mean(hii)
cv[i] <- sum(((y-h.y)/(1-hii))^2)/n
gcv[i] <- sum(((y-h.y)/(1-av.hii))^2)/n
}
return(list(h.v=h.v,cv=cv,gcv=gcv))
}
x = aircraft$Yr
y = lgWeight
h.v <-  exp(seq(from=log(1), to = log(20), length=30))
out.h.cv <- h.cv.gcv(x, y, h.v=h.v)
h.loo.cv <- h.v[which.min(out.h.cv$cv)]
plot(h.v,out.h.cv$cv, xlab ="bandwidth", ylab = "mean ssr")
lines(h.v,out.h.cv$cv)
abline(v = h.loo.cv, col = "red")
aircraft.lp_reg <-locpolreg(x, y,h=h.loo.cv,
xlab = "Year", ylab = "log Weight")
legend("topleft", legend = "m_hat", col = "blue", lty = 1, lwd=2)
m_hat = aircraft.lp_reg$mtgr
epsilon_hat <- y - m_hat
z <- log(epsilon_hat^2)
h.v_z <-  exp(seq(from=log(1), to = log(30), length=30))
out.h.cv_z <- h.cv.gcv(x, y=z, h.v=h.v_z)
h.loo.cv_z <- h.v[which.min(out.h.cv_z$cv)]
plot(h.v_z,out.h.cv_z$cv, xlab ="bandwidth", ylab = "mean ssr")
lines(h.v_z,out.h.cv_z$cv)
abline(v = h.loo.cv_z, col = "red")
aircraft.lp_reg2 = locpolreg(x, z, h = h.loo.cv_z,
ylim = c(min(z), 5),
xlab = "Year", ylab = "log Squared est. residuals")
legend("topleft", legend = "q_hat", col = "blue", lty = 1, lwd=2)
q_hat = aircraft.lp_reg2$mtgr
sigma_square_hat = exp(q_hat)
plot(x, epsilon_hat^2, xlab = "Year", ylab = "Squared est. residuals", col="grey", cex=0.7)
lines(x, sigma_square_hat, col = "blue",lwd=1.5)
plot_aux <- locpolreg(x, y ,h=h.loo.cv, xlab = "Year", ylab = "log Weight", cex = 0.7)
lines(x, m_hat, type = "l", col = "blue")
lines(x, m_hat + 1.96 * sqrt(sigma_square_hat), col = "red", lty=2, lwd=1.5)
lines(x, m_hat - 1.96 * sqrt(sigma_square_hat), col = "red", lty=2, lwd=1.5)
grid(col = "gray", lty = "dotted")  # Add grid
# Add legend with adjusted parameters
legend("topleft", legend = c("Data", "m_hat", "Confidence Interval"),
col = c("grey", "blue", "red"),
lty = c(NA, 1, 2), pch = c(1, NA, NA), lwd = 1.5, cex = 0.8)
data <- read.csv2('HDI.2017.subset.csv')
# Function to estimate the log-likelihood of a Poisson distribution
# via cross-validation
loglik.CV.poisson <- function(X, Y, h){
n <- length(X)
pred <- sapply(1:n,
function(i, X, Y, h){
sm.poisson(x = X[-i], y = Y[-i], h = h, eval.points = X[i],
display = "none")$estimate
},   X, Y, h)
like <- exp(-pred)*(pred^Y)/factorial(Y)
return(mean(log(like)))
}
h.cv.sm.poisson <- function(X, Y, h.range=NULL, l.h=10, method=loglik.CV.poisson){
cv.h <- numeric(l.h)
if (is.null(h.range)) {
hh <- c(h.select(X, Y, method = "cv"),
h.select(X, Y, method = "aicc"))
h.range <- range(hh)*c(1/1.1, 1.5)
}
i <- 0
gr.h <- exp(seq(log(h.range[1]), log(h.range[2]), l = l.h))
for (h in gr.h) {
i <- i + 1
cv.h[i] <- method(X, Y, h)
}
return(list(h = gr.h,
cv.h = cv.h,
h.cv = gr.h[which.max(cv.h)]))
}
le.fm.r <- round(data$le.fm)
h.CV.loglik <- h.cv.sm.poisson(X = data$Life.expec, Y = le.fm.r, h.range = c(1,20),
method = loglik.CV.poisson)
plot(h.CV.loglik$h,h.CV.loglik$cv.h, main = "Log-Likelihood ~ h",
xlab = "h", ylab = "CV-LogLikelihood")
lines(h.CV.loglik$h,h.CV.loglik$cv.h)
knitr::opts_chunk$set(echo = TRUE)
# Clears plots
while (dev.cur() != 1) {
dev.off()
}
# Clears global environment
rm(list = ls())
set.seed(1234)
library(sm)
data(aircraft)
help(aircraft)
attach(aircraft)
lgPower <- log(Power)
lgSpan <- log(Span)
lgLength <- log(Length)
lgWeight <- log(Weight)
lgSpeed <- log(Speed)
lgRange <- log(Range)
plot(Yr, lgWeight)
# Function loc.pol.reg option
source("locpolreg.R")
# Leave-one-out CV to select bandwidth
h.cv.gcv <- function(x, y , h.v = exp(seq(log(diff(range(Yr))/20),
log(diff(range(Yr))/4), l = 10)),
p = 1, type.kernel = "normal") {
cv <- h.v*0
gcv <- h.v*0
for (i in (1:length(h.v))) {
h <- h.v[i]
aux <- locpolreg(x = x, y = y, h = h, p = p, tg = x,
type.kernel = type.kernel, doing.plot = FALSE)
S <- aux$S
h.y <- aux$mtgr
hii <- diag(S)
av.hii <- mean(hii)
cv[i] <- mean(((y - h.y)/(1 - hii))^2)
gcv[i] <- mean(((y - h.y)/(1 - av.hii))^2)
}
return(list(h.v = h.v, cv = cv, gcv = gcv))
}
h.v <-  exp(seq(from = log(1), to = log(20), length = 30))
out.h.cv <- h.cv.gcv(x = aircraft$Yr, y = lgWeight, h.v = h.v)
h.loocv <- h.v[which.min(out.h.cv$cv)]
# Function sm.regression option
library(KernSmooth)
h_m <- dpill(Yr, lgWeight)
aircraft.sm_reg <- sm.regression(Yr, lgWeight, h_m,
eval.points = seq(min(Yr), max(Yr), length.out = length(Yr)))
yhat.sm <- aircraft.sm_reg$estimate
epsilon.sm <- (lgWeight - yhat.sm)^2
z.sm <- log(epsilon.sm)
h2_sm <- dpill(Yr, z.sm)
aircraft.sm_reg2 <- sm.regression(Yr, z.sm, h2_sm,
eval.points = seq(min(Yr), max(Yr), length.out = length(Yr)),
ylim = c(min(z.sm), 5),
xlab = "Year", ylab = "log Squared est. residuals",
lwd = 2, col = "blue", cex = 0.7)
q_hat = aircraft.sm_reg2$estimate
legend("topleft", legend = "q_hat", col = "blue", lty = 1, lwd = 2)
sigma_square_hat = exp(q_hat)
year.points = aircraft.sm_reg$eval.points
# Plot squared residuals against x_i
plot(year.points, epsilon.sm, xlab = "Year", ylab = "Squared est. residuals", col = "grey", cex = 0.7)
# Superimpose the estimated function sigma_square_hat
lines(year.points, sigma_square_hat, col = "blue",lwd = 1.5)
legend("topleft", legend = "sigma_square_hat", col = "blue", lty = 1, cex = 0.8, lwd = 1.5)
# Plot the estimate m_hat
plot(Yr, lgWeight, xlab = "Year", ylab = "log Weight", col = "grey", cex = 0.7)
lines(year.points, yhat.sm, type = "l", col = "blue", lwd = 1.5)
# Superimpose the estimated function sigma_square_hat
lines(year.points, yhat.sm + 1.96 * sqrt(sigma_square_hat), col = "red", lty = 2, lwd = 1.5)
lines(year.points, yhat.sm - 1.96 * sqrt(sigma_square_hat), col = "red", lty = 2, lwd = 1.5)
# Add legend with adjusted parameters
legend("topleft", legend = c("Data", "m_hat", "Confidence Interval"),
col = c("grey", "blue", "red"),
lty = c(NA, 1, 2), pch = c(1, NA, NA), lwd = 1.5, cex = 0.8)
data <- read.csv2('HDI.2017.subset.csv')
# Function to estimate the log-likelihood of a Poisson distribution
# via cross-validation
loglik.CV.poisson <- function(X, Y, h){
n <- length(X)
pred <- sapply(1:n,
function(i, X, Y, h){
sm.poisson(x = X[-i], y = Y[-i], h = h, eval.points = X[i],
display = "none")$estimate
},   X, Y, h)
like <- exp(-pred)*(pred^Y)/factorial(Y)
return(mean(log(like)))
}
h.cv.sm.poisson <- function(X, Y, h.range=NULL, l.h=10, method=loglik.CV.poisson){
cv.h <- numeric(l.h)
if (is.null(h.range)) {
hh <- c(h.select(X, Y, method = "cv"),
h.select(X, Y, method = "aicc"))
h.range <- range(hh)*c(1/1.1, 1.5)
}
i <- 0
gr.h <- exp(seq(log(h.range[1]), log(h.range[2]), l = l.h))
for (h in gr.h) {
i <- i + 1
cv.h[i] <- method(X, Y, h)
}
return(list(h = gr.h,
cv.h = cv.h,
h.cv = gr.h[which.max(cv.h)]))
}
le.fm.r <- round(data$le.fm)
h.CV.loglik <- h.cv.sm.poisson(X = data$Life.expec, Y = le.fm.r, h.range = c(1,20),
method = loglik.CV.poisson)
plot(h.CV.loglik$h,h.CV.loglik$cv.h, main = "Log-Likelihood ~ h",
xlab = "h", ylab = "CV-LogLikelihood")
lines(h.CV.loglik$h,h.CV.loglik$cv.h)
